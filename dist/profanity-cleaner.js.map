{"version":3,"file":"profanity-cleaner.js","mappings":"CAAA,SAA2CA,EAAMC,GAC1B,iBAAZC,SAA0C,iBAAXC,OACxCA,OAAOD,QAAUD,IACQ,mBAAXG,QAAyBA,OAAOC,IAC9CD,OAAO,GAAIH,GACe,iBAAZC,QACdA,QAA0B,iBAAID,IAE9BD,EAAuB,iBAAIC,GAC5B,CATD,CASGK,MAAM,KACT,O,m8DCTA,IAAMC,EAAkBC,EAAQ,KA0BhC,SAASC,EAAMC,GAAoB,IAAdC,EAAU,UAAH,6CAAG,CAAC,EAExBC,EAAiB,CACrBC,YAAa,IACbC,eAAe,EACfC,gBAAgB,EAChBC,WAAY,GACZC,sBAAsB,EACtBC,kBAAmB,KACnBC,qBAAqB,EACrBC,oBAAoB,EACpBC,kBAAmB,EACnBC,YAAa,KACbC,eAAgB,IAGZC,EAAS,EAAH,KACPZ,GACAD,GAGCc,EAAgB,YAAIlB,GAAe,EAAKiB,EAAOD,iBAAiBG,KAAI,SAACC,GAAI,OAAKA,EAAKC,QAAQ,MAAO,OAAO,IAK3GC,EAAQ,IAAIC,OAAOL,EAAcM,KAAK,KAAM,KAehD,OAbKP,EAAOV,gBACVe,EAAQ,IAAIC,OAAOL,EAAcM,KAAK,KAAM,OAE1CP,EAAOT,iBACTc,EAAQ,IAAIC,OAAO,OAAD,OAAQL,EAAcM,KAAK,KAAI,QAAQ,OAEvDP,EAAOL,sBACTU,EAAQ,IAAIC,OAAOL,EAAcM,KAAK,KAAM,OAMvCrB,EAAKkB,QAAQC,GAAO,SAACG,GAE1B,GAAIA,EAAMC,OAAST,EAAOH,kBACxB,OAAOW,EAIT,GAAkC,mBAAvBR,EAAOF,cAA+BE,EAAOF,YAAYU,GAClE,OAAOA,EAIT,GAAIR,EAAOR,WAAWkB,SAASF,EAAMG,eACnC,OAAOH,EAIT,GAAwC,mBAA7BR,EAAON,kBAChB,OAAOM,EAAON,kBAAkBc,GAIlC,GAAIR,EAAOP,qBACT,MAAO,GAAP,OAAUe,EAAM,IAAE,OAAGR,EAAOX,YAAYuB,OAAOJ,EAAMC,OAAS,IAAE,OAAGD,EAAMA,EAAMC,OAAS,IAK1F,IAAII,EAAeb,EAAOX,YAAYuB,OAAOJ,EAAMC,QAGnD,GAAIT,EAAOJ,mBAAoB,CAC7B,IAAMkB,EAAYN,EAAM,GAClBO,EAAWP,EAAMA,EAAMC,OAAS,GAClCK,EAAUN,MAAM,aAClBK,EAAe,GAAH,OAAMC,GAAS,OAAGD,EAAaG,UAAU,KAEnDD,EAASP,MAAM,aACjBK,EAAe,GAAH,OAAMA,EAAaG,UAAU,EAAGH,EAAaJ,OAAS,IAAE,OAAGM,GAE3E,CAEA,OAAOF,CACT,GACF,CAeAlC,EAAOD,QAAU,CACfO,MAAAA,EACAgC,UAPF,SAAmB/B,GAAoB,IAAdC,EAAU,UAAH,6CAAG,CAAC,EAC5B+B,EAAcjC,EAAMC,EAAMC,GAChC,OAAO+B,IAAgBhC,CACzB,E,ugIC5HIiC,EAA2B,CAAC,EAGhC,SAASC,EAAoBC,GAE5B,IAAIC,EAAeH,EAAyBE,GAC5C,QAAqBE,IAAjBD,EACH,OAAOA,EAAa5C,QAGrB,IAAIC,EAASwC,EAAyBE,GAAY,CAGjD3C,QAAS,CAAC,GAOX,OAHA8C,EAAoBH,GAAU1C,EAAQA,EAAOD,QAAS0C,GAG/CzC,EAAOD,OACf,CCnB0B0C,CAAoB,K,MDF1CD,C","sources":["webpack://profanityCleaner/webpack/universalModuleDefinition","webpack://profanityCleaner/./src/index.js","webpack://profanityCleaner/webpack/bootstrap","webpack://profanityCleaner/webpack/startup"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"profanityCleaner\"] = factory();\n\telse\n\t\troot[\"profanityCleaner\"] = factory();\n})(this, () => {\nreturn ","/* eslint-disable max-len */\nconst defaultBadWords = require('./badWords.json');\n\n/**\n * A function to censor bad words in a given text.\n *\n * @param {string} text - The input text to be censored.\n * @param {Object} [option={}] - The options object for censoring the text.\n * @param {string} [options.placeholder='*'] - The character to replace bad words with.\n * @param {boolean} [options.caseSensitive=false] - Whether to consider the case of the words while censoring.\n * @param {boolean} [options.wholeWordsOnly=true] - Whether to consider only whole words while censoring.\n * @param {string[]} [options.exceptions=[]] - An array of words that should not be censored.\n * @param {boolean} [options.keepFirstAndLastChar=false] - Whether to keep the first and last characters of the bad words while censoring.\n * @param {function} [options.customReplacement=null] - A custom function to replace bad words. The function should take in a single argument (the bad word) and return the replacement string.\n * @param {boolean} [options.replacePartialWords=false] - Whether to consider partial words while censoring.\n * @param {boolean} [options.includePunctuation=false] - Whether to keep the punctuation at the beginning and end of the bad words while censoring.\n * @param {number} [options.minimumWordLength=1] - The minimum length of a word that should be censored.\n * @param {function} [options.customMatch=null] - A custom function to decide which words should be censored. The function should take in a single argument (the bad word) and return a boolean value indicating whether the word should be censored.\n * @param {string[]} [options.customBadWords=[]] - An array of additional bad words to censor.\n * @returns {string} The censored text.\n *\n * @example\n *\n * const profanityCleaner = clean('This is a fucking example.');\n * console.log(profanityCleaner); // Output: \"This is a ******* example.\"\n */\n\nfunction clean(text, options = {}) {\n  // Set default options\n  const defaultOptions = {\n    placeholder: '*',\n    caseSensitive: false,\n    wholeWordsOnly: true,\n    exceptions: [],\n    keepFirstAndLastChar: false,\n    customReplacement: null,\n    replacePartialWords: false,\n    includePunctuation: false,\n    minimumWordLength: 1,\n    customMatch: null,\n    customBadWords: [],\n  };\n\n  const option = {\n    ...defaultOptions,\n    ...options,\n  };\n\n  const censoredWords = [...defaultBadWords, ...option.customBadWords ].map((word) => word.replace(/\\*/g, '\\\\w+'));\n\n  // console.log(censoredWords);\n\n  // Create a regular expression based on the options\n  let regex = new RegExp(censoredWords.join('|'), 'g');\n\n  if (!option.caseSensitive) {\n    regex = new RegExp(censoredWords.join('|'), 'gi');\n  }\n  if (option.wholeWordsOnly) {\n    regex = new RegExp(`\\\\b(${censoredWords.join('|')})\\\\b`, 'gi');\n  }\n  if (option.replacePartialWords) {\n    regex = new RegExp(censoredWords.join('|'), 'gi');\n  }\n\n  // console.log(regex);\n\n  // Replace the censored words with the censor character or custom replacement\n  return text.replace(regex, (match) => {\n    // Check if the word is shorter than the minimum length\n    if (match.length < option.minimumWordLength) {\n      return match;\n    }\n\n    // Check if the word matches the custom match function\n    if (typeof option.customMatch === 'function' && !option.customMatch(match)) {\n      return match;\n    }\n\n    // Check if the word is in the exceptions list\n    if (option.exceptions.includes(match.toLowerCase())) {\n      return match;\n    }\n\n    // Use the custom replacement function if provided\n    if (typeof option.customReplacement === 'function') {\n      return option.customReplacement(match);\n    }\n\n    // Keep the first and last characters of the word\n    if (option.keepFirstAndLastChar) {\n      return `${match[0]}${option.placeholder.repeat(match.length - 2)}${match[match.length - 1]}`;\n    }\n\n\n    // Censor the entire word\n    let censoredWord = option.placeholder.repeat(match.length);\n\n    // Keep the punctuation at the beginning and end of the word\n    if (option.includePunctuation) {\n      const firstChar = match[0];\n      const lastChar = match[match.length - 1];\n      if (firstChar.match(/[^\\w\\s]/)) {\n        censoredWord = `${firstChar}${censoredWord.substring(1)}`;\n      }\n      if (lastChar.match(/[^\\w\\s]/)) {\n        censoredWord = `${censoredWord.substring(0, censoredWord.length - 1)}${lastChar}`;\n      }\n    }\n\n    return censoredWord;\n  });\n}\n\n/**\n * A function to check if a given text contains any bad words.\n *\n * @param {string} text - The input text to check.\n *\n * @returns {Boolen}\n * */\n\nfunction isProfane(text, options = {}) {\n  const cleanedText = clean(text, options);\n  return cleanedText !== text;\n}\n\nmodule.exports = {\n  clean,\n  isProfane,\n};","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(380);\n"],"names":["root","factory","exports","module","define","amd","this","defaultBadWords","require","clean","text","options","defaultOptions","placeholder","caseSensitive","wholeWordsOnly","exceptions","keepFirstAndLastChar","customReplacement","replacePartialWords","includePunctuation","minimumWordLength","customMatch","customBadWords","option","censoredWords","map","word","replace","regex","RegExp","join","match","length","includes","toLowerCase","repeat","censoredWord","firstChar","lastChar","substring","isProfane","cleanedText","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__"],"sourceRoot":""}